<h1>hello this is my web</h1>
<h2>hello this is my web</h2>
<h3>hello this is my web</h3>
<h4>hello this is my web</h4>

 <ol>
     <li>beer</li>
     <li>김치</li>
     <li>meat</li>
     <li>milk</li>
 </ol>

 <a href="http://google.com" target="_self">Go to google</a>
 <img src="https://t1.daumcdn.net/cfile/tistory/9906804C5FB7337315"/>
 <img src="img/inzuna.jpg"/> -> 이거는 컴퓨터 내 이미지가 home.html과 다른 폴더에 있을 때
 <img src="inzuna.jpg"/> -> 이거는 컴퓨터 내 이미지가 home.html과 같은 폴더에 있을 때

 <!DOCTYPE html>
<html lang="kr">
    <head>
        <*link rel="stylesheet" href="styles.css"/> -> 2.(다른 파일에 있는 CSS를 HTML에 추가하는 법) CSS가 다른 파일(styles.css)가 있는데 이 시트(HTML)와 연결시켜주는 태그 명령
        <*style> -> 1.(HTML파일에 CSS코드를 직접 써넣는 방법)style태그 내에 CSS코드를 작성하면됨

        </style>
        <link rel="shortcut icon"  sizes="16x16 32x32 64x64" href="https://nomadcoders.co/m.png"/>
        <title>Home - my  first website.</title>
        <meta name="description" content="this is my website"/> - > 검색했을 때 부제목(description)같은 거임, content: 내용물
        <meta charset="utf-8"/> -> 특수문자 같은 걸 브라우저에게 이해시키기 위한 구문
        <meta property="og:title" content="nomadcoders"/>-> 카카오톡 같은 걸로 공유할 때 뜨는 제목
    </head>
    <body>
        <h1>
            hello!
        </h1>
        <a href="http://naver.com" target="_blank">go other page</a>
        <img src="inzuna.jpg"/>
        <p>alalalalalalal</p>
        <pre>hello!</pre>

        <p>You can use <abbr title="Cascading style sheets">CSS
        </abbr>to style your <abbr title="HyperText Markup Language">HTML</abbr></p>

        <a href="http://google.com"><cite>출처</cite></a> ->여기서 cite는 기울임꼴만 적용해줌
        <p>hello my <mark>world!</mark></p>
        <p>hello my <strong>world!</strong></p>
        <p>2 <sup>5</sup></p>
        <audio controls="enabled" autoplay="enabled" src="https://interactive-examples.mdn.mozilla.net/media/cc0-audio/t-rex-roar.mp3"></audio>
        <dialog open><p>Greetings, one and all!</p></dialog>->상자

        4/11
        <form>
            <label for="profile">Profile Photo</label>->label은 input과 같이 사용해야함, label의 for라는 attribute의 값과 input의 id값은 같은 걸로 해줘야함
            <input id="profile" type="file" accept=".jpg, .pdf"/> ->accept는 조건 같은거임 받아들이는 항목을 말함
            <input type="file" accept="image/*"/> ->모든 이미지를 말함
            <p> </p>
            <label for="first-name">First name</label>
            <input id="first-name"" required placeholder="Name" type="text"/>
            <input required placeholder="Last Name" type="text"/>
            <input required placeholder="Username" type="text"/>
            <input required placeholder="Password" minlength="10" type="password"/>
            <input type="submit" value="Create Account"/>

            
            <div>
                <label for="website">Website</label>
                <input id="website" required placeholder="website" type="date"/>
            </div>
            <div>
                <input type="submit" value="Creat Account"/>
            </div> -> 박스 등을 위아래로 분할해주는 역할//Header,main,footer을 대체할 수 있음. 그러나 코드 이해에 어려움이 생김. 쓰지마
        </form>
        
        <div>
            <h1>This is my world</h1>
        </div>
        <main>
            <span>hello!</span> ->span: 짧은 글을 위한 tag
            <address>홍천로 4444</address>
        </main>
        <footer> ->꼬릿말을 위한 tag
            &copy; 2020 N.C
        </footer>
    </body>
</html>

-----------------CSS작성법-----
(태그값 or id값)
가르키는 것{ 
    지정해줄 속성: 값;
    color: blue;
    font-size:20px;}
    <style>
        h1{
            color: blue;
            font-size:20px;
            text-decoration: underline;
            font-weight: 200;
            font-style:italic;
        }
        address{
            text-align: center;
            color:tomato;
        }
    </style>

---------block & inline------
<body>
    <div></div>
    <div></div>
    <div></div>->박스 형태로 옆에 아무것도 못옴 ㅂㄱㄴ(block)
    <span>hello</span>->옆에 올 수 있음 ㄱㄴ(inline=in the same line)
    <span>hello</span>
    <span>hello</span>
    <a href="#">link</a> -> 옆에 올 수 있음 ㄱㄴ(inline)
    <img src="inzuna.jpg"/> -> 옆에 올 수 있음 ㄱㄴ(inline)
    <span>hello</span>
    <address>우리집</address> ->옆에 올 수 없음 ㅂㄱㄴ(block)
    <blockquote>hooooooo</blockquote> ->옆에 올 수 없음 ㅂㄱㄴ(block)
    <span>hello</span>
    <p>ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ</p>-> 옆에 올 수 없음 ㅂㄱㄴ(block)
     
    inline = 아주 작은 글이나 링크, 그림 등(span, a,link 등)
    block= 대부분의box
</body>
이런 식으로 작성
    
------------------block을 inline으로, inline을 block으로 바꾸는 게 가능하다(display속성 in CSS)-----
<style>
    span{
        display: block;
    }
    div{
        display: inline;
    }
</style>
----> span은 원래 inline인데 display속성을 이용해 block으로 바꿔줌. div도 마찬가지.
--> [중요!] 어떤 속성이 inline이면 높이와 너비가 없다./block은 이를 가진다. -> inline은 글자에 의해 높이와 너비가 정해지므로 글자가 없으면 아무것도 보이지 않는다.
--> block은 box, inline은 not box
-->box는 3가지 특징을 가짐. margin(box의 경계(border)의 바깥에 있는 공간), border, padding.

1. margin: body라는 box의 경계로부터 바깥에 있는 공간. margin크기 설정은 style에서 
<style1>
    body{margin: 15px(전체);}
    body{margin: 20px(위, 아래) 15px(양 옆);} 해주면 됨
    body{margin: 20px(위) 5px(오른쪽) 12px(아래) 9xp(왼쪽);} 해주면 됨

    div{margin: 20px;}
</style1>
->여기서 만약 body와 div의 위, 아래 margin 경계가 닿아서(만나면), 경계의 위, 아래에서 collapsing margins(위, 아래 경계가 만난 margin은 하나로 취급)효과가 나타남.

2.padding: box의 경계로부터 '안쪽'에 있는 공간 -> 적용하면 그 크기만큼 바깥쪽으로 늘어남
->style 즉, CSS에서 id를 가르키는 법: #id명 ex): #id

<style2>
div{
    padding: 10px;
}

#first{
    background-color: whitesmoke;
    height: 150px;
    width: 150px;
}
#second{
    background-color: teal;
    height: 100px;
    width: 100px;
}
#third{
    background-color: wheat;
    height: 50px;
    width: 50px;
}
#fourth{
    background-color: blanchedalmond;
    height: 25px;
    width: 25px;
}
</style2>
</head>
<body>
<div id="first">
<div id="second">
    <div id="third">
        <div id="fourth"></div>
    </div>
</div>
</div>
</body>

3.border: box의 경계를 의미함. box만이 아니라 inline에도 border는 적용됨

*{
    border: 2px solid black;
}  -> *:전체를 말하는 거임/ border: 너비 스타일 색깔;


inline은 padding(사방 다 적용)적용도ㅣ고, margin은 양 옆으로만 적용됨(inline은 높이와 너비가 없기 떄문)

4.Class: 특정 대상들에게 같은 요소를 적용하고플 때 쓰임. class명은 같아도 됨.
->사용법: CSS파일(또는 style태그) 내에서 .(온점)클래스명으로 언급 해줌.
-> #tomato = id ="tomato"
   .tomato = class= "tomato"
-> 한 태그 내에 클래스명이 여러 개일 수 있다. <-> 반면 id는 하나만 가져야함
   <span class="for1 for2 for3 for4"></span>

<style->
    .for1{
        background-color: tomato;
    }
</style->


<body2>
    <span>hello</span>
    <span class="for1">hello</span>
    <span>hello</span>
    <span class="for1">hello</span>
    <span>hello</span>
    <span class="for1">hello</span>
</body2>

3.9 lnline-block: 속성은 block이지만 같은 줄에 놓이도록 해줌.
-> div{display: inline-block;}
-> 문제가 많음. 같은 줄에 놓였고 block이지만 두 block사이에 빈 공간이 생김. 다 지멋대로임, 반응형 디자인을 지원하지 않음



4/13


3.10 flexbox: 박스들을 원하는 곳에 둘 수 있다. 말 그대로 유연함.
-> 사용시 지켜야 할 세가지 규칙
1. 자식 엘리먼트에는 어떤 것도 명시하지 말아야 함. 즉, 부모 엘리먼트에게만 말해야 함. ex): div는 body에 적는다. 여기서 부모: body , 자식: div  + body 내의 tag들
   -> 부모 엘리먼트를 flex만들어야 함! (body가 자식 엘리먼트들을 제어함)
      하는 법: CSS에서 body{display: flex;}


2,3: 주축(main axis-x축)와 교차축(cross axis- y축 반대로(-y축))
CSS에서
    body{
        display:flex; -> 이런 식으로 flex를 해줘야 body내의 contents에게 아래 명령들을 실행할 수 있음.
        justify-content: space-evenly; ->body내의 내용물들의 주축 위치 조정/ 이건 주축에 적용되는 부분임( 나중에 교차축 적용으로 바꿀 수 ㅇ)
        align-items: center; ->body내의 내용물들의 교차축 위치 조정/body가 충분한 height를 가지지 않으면 적용되지 않음/ 이건 교차축에 적용. (나중에 주축 적용으로 바꿀 수 ㅇ)
    }

새로 배운 단위: vh -> view point 화면 크기에 따라 그 단위가 달라짐

3.11 Flexbox 2 
 1. 주축과 교차축을 서로 반대로 바꾸어주기
-> CSS의 부모 엘리먼트에 flex-direction을 적어주기
-> body{
    flex-direction: colunm; -> 주축이 -y축이 됨(align-items: x축)
    flex-direction: colunm-reverse; 주축이 +y축이 됨(align-items: x축)
    flex-direction: row; -> 주축이 x축이 됨(align-items: -y축)
    flex-direction: row-reverse; -> 주축이 -x축이 됨(align-items: -y축)
    -> reverse는 주축의 방향만 바뀜

} 
 2. flex컨테이너(body 등)의 자식 엘리먼트(예를 들어 div) 등도 flex컨테이너(body가 하던 역할- 명령을 내리는 역할)가 될 수 ㅇㅇ
  -> 조건: div또는 그 외의 body의 자식 엘리먼트 안에 글자or 숫자 같은 또 다른 자식 엘리먼트가 있어야함
           이렇게 되면 div 같은 body의 자식엘리먼트는 부모 엘리먼트가 되고 숫자나 글자는 자식 엘리먼트가 됨
           주의) body는 div안의 글자의 flex 컨테이너가 될 수 없다.

        <head-2예시>
            div{
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 30px;
                color: white;
                width: 300px;
                height: 300px;
                background-color: teal;
            }
        </head->
        <body-예시>
            <div>1</div>
            <div id="second">2</div>
            <div>3</div>
        </body->


 3. flexbox의 속성
  -> flexbox의 width는 초기값이고 모든 엘리먼트를 같은 줄에 있게 하기 위해 width를 바꿀 수 있다. -> 창을 줄여도 div가 같은 줄에 있도록 크기가 줄어들음
     -> flex-wrap: nowrap; 이면 같은 줄에 있도록 크기를 조절
     -> flex-wrap: wrap; 이면 크기가 유지되도록 하고 같은 줄 X
    <style-3>
        <body-3예시>
            height: 100vh;
            margin: 20px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap; -----------> 이거 !!!!! (wrap-reverse도 가능! 축이 거꾸로됨! 주축이 -x축이 됨, 교차축은 그대로임)
            align-items: center;
        </body-3>
    </style-3>
    <body-3>
        <div>1</div>
        <div id="second">2</div>
        <div>3</div>
    </body-3>

  3.12 fixed
    1. position: fixed 
    CSS에서
    div{
        top: 5px;
        right: 5px;
        left: 5px;
        bottom: 5px

        position: fixed; 이거!!!!!!!!!
        width: 300px;
        height: 300px;
        color:white;
        background-color: teal;
    }

    ---> 위치를 정해줄 때 사용( fixed: 스크롤을 내려도 div가 화면에 고정되어 나타남. 고정된 위치는 초기에 위치한 자리. 초기에 중간에 위치하면 중간에 fixed됨. 화면에 고정됐으므로 없어지지 X)
    ---> fixed된 위치는 초기 위치인데 변경시켜 줄 수 있음.-> 이는 맞닿아 있는 레이어 무시할 수 있음(margin개념으로 이용됨/top, right, left, bottom 사용)
    ---> <<<중요 fixed된 위치에 다른 레이어가 있으면 fixed된 레이어가 우세하여 화면상 더 앞쪽에 위치(fixed가 보임)

    <body-에시>
        <div></div>
    </body->

    새로 배운 명령어: opacity: 0.2; --->불투명도 조절 (0.2면 투명해짐)

3.13 Relative, Absolute (position)
 1. position: relative 
- position: static; 초기 위치에 박힘 -> 스크롤 내리면 사라짐
- position: relative; -> relative를 사용하면 top,right,bottom,left사용 ㄱㄴ/ 위치를 아주 조금만 움직일 때 사용 
  -> <<<<<엘레멘트가 초기 위치를 기준으로 이동할 때 사용>>> 

  CSS에서
  .green{
    background-color: teal;
    position: relative; --> 위치 조금 이동 ㄱㄴ
    top: -10px; -> 위치 이동 (위쪽으로 이동함)
    height: 100px;
    width: 100px;
}

<div class="green"></div>

2. position: Absolute; ->top,right,bottom,left를 원할 때 사용 ㄱㄴ
 -특이점: <<가장 가까운(상위 중 가장 가까운) relative부모를 기준으로 이동 -> 없으면 body가 가장 가까운 relative한 부모가 됨. 따라서 body를 기준으로 맨 오른쪽, 아래, 왼쪽 등으로 감
      -> body를 기준으로 하고 싶지 않으면 바로 위 엘레멘트를 relative로 만들기(CSS에서)

    (CSS에서)
      div{
        width: 300px;
        height: 300px;
        background-color: wheat;
        position:relative;  !!--> body가 기준이 되지 않기 위해 바로 위 엘레멘트(부모 엘레멘트)를 relative로 만듦
        }
    .green{
        background-color: teal;
        position: absolute; !!--> 자식 엘레멘트 absolute
        bottom: 0px;
        right: 0px;
        height: 100px;
        width: 100px;
    }

    <body>
        <div> -> 가장 가까운 부모 엘레멘트
            <div class="green"></div> -> 자식 엘레멘트
        </div>
    </body>

3.14 pseudo selectors. part1 
-> CSS에서 id(#),class(.),tag name보다 좀 더 세부적으로 엘레멘트를 선택하는 명령어.
   ex): 처음에 오는 엘레멘트, span 다음에 오는 엘레멘트 등 특정 엘레멘트를 선택하고 싶을 때
     
    <사용법: tag명:엘레멘트 위치{적용할 요소} >
    [CSS안]
    div:first-child{        ---> 첫번째 div에 속성 적용
        background-color: tomato;
        }
    div:last-child{            ---> 마지막 div에 속성 적용
        background-color: teal;
        }  
    span:nth-child(n){           ---> n번째에 있는 span에 속성을 적용하는 명령어
        background-color: red;        짝수 번째에만 속성 적용: ()괄호 안에2n 또는 even적기  span:nth-child(2n){속성}
    }                                 홀수: 2n+1 또는 odd
    
    예시:span:nth-child(2),
        span:nth-child(4) {         -----> 2,4번째에 있는 span에 배경색 적용
        background-color: teal;
    }

    <body>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <div></div>
        <span>hello</span>
        <span>hello</span>
        <span>hello</span>
        <span>hello</span>
        <span>hello</span>
    </body>


3.15 combinations
 1. pseudo selectors의 활용
 [본문 -1]
 <body-활용>
    <div>
        <span>hello</span>    (1번 span)
        <p>
            lorem~~~~~~~~~~~~~~~~~~~~~~~~~mwofmwofmoqfpmfapsnwo
            fmwiqofnqwoifnqwoif.<span>inside</span>
        </p>
    </div>
</body-활용>

 1Q) <p></p> 안에 있는 <span></span> 을 지정하여 속성을 주려면 어케 해야 될까?
  - p: 부모 엘레멘트 , span: 자식 엘레멘트
  A): CSS에서 
    p span{
        color: teal;
    }
이렇게 쓰면 된다. 즉, <부모엘레멘트(space bar)자식엘레멘트{속성}    ---> 부모 엘레멘트에서 자식 엘레멘트를 찾아라라는 명령어임
   
2Q) div안에 있는 p에 속한 span에 속성 주고 싶다!
A) div p span{
    color: teal;
}

3Q) div바로 밑에 있는 자식(direct-child) 엘레멘트 span 즉, 1번 span에만 (p span말고) 속성을 주는 법
A) CSS에서
    div > span{
        text-decoration: underline;
    }
   해주면 됨! 여기서 >는 direct-child만을 가르킨다.

[본문 -2]
<body-본문2>
    <div>
        <p>
        </p>
        <span>hello</span>
    </div>
</body-본문2>

4Q) <p> 바로 다음에 오는 <span> 을 가르켜 속성을 주고 싶다!
A) p + span{
    text-decoration: underline;
}
  해주면 됨! 여기서 + 는 같은 줄에서 바로 다음 엘레멘트를 일컫는 말임.

  정리: 조부모 엘레멘트: g , 부모 엘레멘트:p , 자식 엘레멘트: c , c와 형제이면서 바로 다음 엘레멘트: n , c와 형제 엘레먼트: b
  1. 부모 안의 자식 가르킴
   -> p c{속성}
  2. 조부모부터 자세히 자식 엘레멘트 가르킴
   -> g p c{속성}
  3. 바로 밑 자식 엘레멘트만 가르킴
   -> p > c{속성}

  4. 같은 계열의 바로 다음(direct next, 바로 다음에 없으면 적용 X) 엘레멘트를 가르킴(형제 엘레멘트 찾기)
   -> c + n{속성}
  5. 같은 계열(형제 엘레먼트)에서 바로 다음에 오지 않는 엘레멘트 지정하여 속성 적용
   -> C~b{속성}


   4/14 


3.16 Pseudo Selectors part2

5Q) 같은 계열(형제 엘레먼트)이면서 바로 다음에 오지 않는 엘레멘트 속성 적용
<body>
    <div>
        <p>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa gucci
        </p>hi
        <address></address>
        <span>hello</span>
    </div>
</body>
A) CSS에서
p ~ span{
    text-decoration: underline;
}
해주기! ~는 같은 계열 내에서 특정 엘레멘트를 지정해주는 명령어

6Q) <<<<<특정 attribute를 가지는 엘레멘트 지정하는 법>>>>>
input 중에 required된 엘레멘트만 지정
<div>
    <form>
        <input type="text" placeholder="username" />
        <input type="password" required placeholder="psaaword" />
    </form>
</div>

A) input:required{
    border:1px solid tomato;
}
 -> 엘레멘트명: 특정 attribute명{요소}   -> attribute에 content가 들어가지 않는 요소들 지정할 때
 -> 이 외의 input에서 특정 attribute명 사용하여 엘레멘트 선택하는법
    input: optional{ } / optional은 required를 제외한 한 가지 이상의 attribute를
    가지는 엘레멘트에 적용됨


-----attribute selector-------
1. attribute를 통해 어떠한 엘레멘트를 선택하는 법
  1-1: 엘레멘트명[지정하고픈 attribute]{속성}
Q)<body>
    <div>
        <form>
            <input type="text" placeholder="username" />
            <input type="password" required placeholder="psaaword" />
        </form>
    </div>
</body>

A) input[type="password"]{
    background-color: thistle;
}
-> 이런 식으로 엘레멘트명[지정하고픈 attribute]{속성} 이렇게 주면됨 !

  1-2: 엘레멘트명[지정하고픈 attirbute~ = 내용물]{속성}

Q) placeholder에서 name을 포함하는 모든 엘레멘트 지정 
<body>
    <div>
        <form>
            <input type="text" placeholder="first name" />
            <input type="text" placeholder="last name" />
            <input type="password" required placeholder="psaaword" />
        </form>
    </div>
</body>

A) input[placeholder~="name"]{  ---> ~표시가 굉장히 중요!!
    background-color: pink;
}

위의 placeholder에 name이 들어간 모든ㄴ 엘레멘트에 속성 주기 성공(대신 name이 띄어
쓰기 돼 있어야 함)  -> ~= 무엇을 포함하고 있다는 뜻

 1-3 이 외 attribute selector 정리

 /* <a> elements with a title attribute */
    a[title] {
      color: purple;
    }
    
/* <a> elements with an href matching "https://example.org" */
    a[href="https://example.org"] {
      color: green;
    }
    
/* <a> elements with an href containing "example" */
    a[href*="example"] {
      font-size: 2em;
    }
    
/* <a> elements with an href ending ".org" */   -> 끝에 올 떄
    a[href$=".org"] {
      font-style: italic;
    }
    
/* <a> elements whose class attribute contains the word "logo" */
    a[class~="logo"] {
      padding: 2px;
    }


3.17 States(상태)
 -> 기본 형태 =  엘레멘트:states{속성}
  1.active: 어떠한 버튼을 눌렀을 때 버튼에 변화가 생기는 것. 엘레멘트:active{}
 -> button:active{
    background-color: tomato;
    }
    <button>Hello</button>
  2.hover: 마우스가 커서 위에 올려 놓았을 때 상태 변화.  엘레멘트:hover{}
 -> button:hover{
    background-color: tomato;
    }  
  3. focus: 키보드로 선택됐을 때 상태변화.  엘레멘트:focus{}
 -> button:focus{
    background-color: tomato;
    }
  4. visited: 링크에만 적용. 링크를 누른 뒤(방문한 뒤), 링크 색깔 바뀌는 거 같은 걸 말함.
 -> a:visited{
    color: tomato;
    }
  5.focus-within: 부모 엘레멘트에 적용. focused인 자식을 가지 부모 엘리먼트에 적용.
 - > form{
    border: 1px solid tomato;
    display: flex;
    flex-direction: column;
    padding: 20px;
    }

    form:focus-within{            -----> 이거임! 자식 엘레멘트가 focus되면 부모
        border-color:yellow;              엘레멘트의 상태가 바뀜
    }


 <body>
    <form>
        <input type="text" name="" id=""/>
        <input type="text" name="" id=""/>
        <input type="text" name="" id=""/>

    </form>
</body>

  - state를 다른 엘리먼트와 연계해서 사용 ㄱㄴ
   1. form:hover라면 자식 엘레멘트인 input에 속성을 적용하라(위 5번 본문과 동일) 
    form:hover input{
    background-color:violet;
    }

   2. form:hover가 되고 자식 엘레멘트인 input이 focus가 되면 속성 적용.(위 5번 본문과 동일)
    form:hover input:focus{
    background-color:violet;
    }

 3.18 Recap
  - Styling 3가지 -> :: (따옴표 2개)
   1. Placeholder 스타일링 
   -> input::placeholder{
      color:slateblue;
      }

   <input type="text" placeholder="name"/>
    
   2. Selection 스타일링 -> 마우스로 본문 드래그 할 때 효과 적용
 -> p::selection{
    background-color:slateblue;
    color:white;
    }

    <p>
        lorem sdasdasdqwdqwdasdasd
    </p>

  3.first-letter 스타일링 -> 본문 첫글자
  -> p::first-letter{
    font-size: 50px;
    background-color:slateblue;
    color: white;
    }

    <p>
        lorem sdasdasdqwdqwdasdasd
    </p>

이 외에도 있으니 찾아보길 ... ex): first-line 등


3.19 Colors and variables(변수)
 1. color를 지정하는 방법
   - color: #컬러코드;   -> 원하는 컬러를 아무 웹 사이트에서 선택한 뒤(color picker사용) 붙여넣기 하면 됨
   - color: rgb(252, 206,0);
   - color: rgba(252, 206,0, 투명도(0~1));

 2. 변수
 CSS안에서
 :root{                              -> CSS내의 모든 변수를 만드는 곳(:root)
    --main-color: #fcce00;           -> 변수명 만드는 법: dash(-) 2개 + 역할 + dash(-) 1개 + 변수이름
    --default-border: 1px solid var(--main-color);    -> 변수 내에서 변수 사용 ㄱㄴ
      }   
 p{
    color: var(--main-color);
      }
 a{
    color: var(--main-color);       -> 변수 적용법 var(변수명)
    border: var(--default-border);
      }

4.0 ~ 4.1 Transitions: 어떤 상태에서 다른 상태로의 변화(상태 변화 즉, state를 지정한 CSS가 있어야 적용 ㄱㄴ)를 애니메이션으로 만드는 방법
 -> Transition이란 속성은 state가 없는 요소에 붙어야함!!!!!!!!!!!중요
 -> Transition으로 바꿀 속성이 state상에 있어야함 기본->다른 state로 변할 때 애니메이션 적용하기 때문
    a{
        color:wheat;
        background-color: tomato;
        text-decoration: none;
        padding: 3px 5px;
        border-radius: 5px;
        font-size: 55px;
        transition: background-color 10s ease-in-out, color 5s ease-in-out;  -> transition: 바꿀요소 변화시간 ease-in-out등 요소;
    }                                                                           만약 hover로 바뀔 때 모든 요소 변화시킬거면 바꿀 요소에 all써주삼      
    a:hover{                                                                    Transition이란 속성은 state가 없는 요소에 붙어야함
        color:tomato;                                                           
        background-color: wheat;
    }

    <a href="#">go home</a>

    -----> ease-in-out: 기본적으로 브라우저에게 애니메이션이 아떻게 변할지 말해주는거(https://matthewlein.com/tools/ceaser) 여기서 자세히 보기
           cubic-bezier(0.550, 0.085, 0.680, 0.530), 이런 형태로도 쓸 수 있음

4.2ㅅTransformation: 한 요소를 변형시키ㅣ는 명령어

- transformation은 한 요소를 transform(변형)시킬 수 있다. -> 3차원 작업을 할 수 있다.
- border-radius에 50%를 준다면 원이 된다.
- translate은 transformation을 적용 시키긴 하지만, 다른 형제(sibling)을 변화시키진 않는다.
→ transformation은 box element를 변형시키지 않는다.
→ margin, padding이 적용되지 않는다. 일종의 3D transformation이기 때문이다.
→ margin, padding을 위해서 translateX, translateY를 사용하지 않는다.
- transform과 transition을 조합하면 더 역동적인 애니메이션을 만들 수 있다.
- CSS 3D는 GPU로 돌아가므로, 3D 작업을 할 수 있다.

-예시들
    transform: rotateY(80deg) rotateX(30deg);     -> 이런식으로 3D 작업이 ㄱㄴ하다
    transform: scale(2,2) -> x,y축으로 각각 2배로 늘어남
    ransform: translate(20px,30px);  -> x,y축으로 이동하는 거임(다른 형제와 Box element는 변화X 즉, transform된 개체의 영향을 받지 않음)


- - transform과 transition을 조합하면 더 역동적인 애니메이션을 만들 수 있다.

img{
    border: 5px solid black;
    border-radius: 50%;
    transition: transform 5s ease-in-out;
}
img:hover{
    transform: rotateX(360deg) scale(0.5);
}

<img src="img/logo.jpg" />



4.3 Animations part.1
- 상태 변화없이 계속 돌아가는 애니메이션을 만들것임
- 애니메이션 만들기
@keyframes 애니매이션이름{
    from{
        효과(예를 들어 transform: rotateX(0deg);
    }
    to{
        효과(예를 들어 transform: rotateX(360deg) translateX(100px);
    }
}
img{
    animation: 애니메이션이름 지속시간(5s 등) ease-in-out등 infinite(무제한 사용시에만 더 붙여줌);
}

<img src="img/logo.jpg" />

4.4 Animations part.2
- 애니메이션이 작동 후 제자리로 애니메이션 이동이 아닌 점프하는 경우, 사용 
  -> 0%: 시작할 때, 50%: 주고싶은 효과, 100%: 0%와 동일한 코드(그래야 시작점으로 자연스럽게 애니메이션으로 돌아감)
@keyframes mycoin{
    0%{
        transform: rotateX(0deg);
    }
    50%{
        transform: rotateX(360deg) translate(100px);
    }
    100%{
        transform: rotateX(0deg);
    }
}
mg{
    animation: 애니메이션이름 지속시간(5s 등) ease-in-out등 infinite(무제한 사용시에만 더 붙여줌);
}

<img src="img/logo.jpg" />

- from to 말고, 1,2,3,4,5...10 혹은 0% 25% 50% 75% 100% 같이 여러 단계로 나뉘어 애니매이션을 만들 수 있다.
- 다른 property들도 애니매이션으로 만들 수 있다. 꼭 transform만 써야하는 건 아니지만, transform을 쓰는걸 권한다. 일부 property는 애니매이션이 잘 안되기 때문이다.
-opacity:불투명도

4.5 ~ 4.6 Media Queries(오직 핸드폰에만 적용이 됨): css만을 이용해서 스크린의 사이즈(사용자의 스크린 사이즈)를 알 수 있는 방법
-> 즉, 폰의 가로모드, 엄청 큰 화면으로 보기 등 화면의 사이즈가 달라질 때, 이러한 css를 보여줘! 라는 명령어
-> 어떤 조건이 참이라면, 이 CSS를 적용해라 이런 일종의 함수임
- Media query는 오직 CSS만을 이용해서 스크린의 사이즈를 알 수 있는 방법이다.(웹사이트를 보고 있는 사용자의 스크린 사이즈)
- @media screen and (max-width: 00px) {} 을 이용하여 몇 픽셀부터는 달라보이도록 만들 수 있다. 이를 통해 스크린의 사이즈를 알 수 있다.
- min 사이즈와 max사이즈를 조절하여 단계별로 만들면, 스크린 사이즈의 범위를 알 수 있다.
- 브라우저에서 inspect의 device toolbar를 이용하여 핸드폰 기종 별 사이즈로 브라우저를 볼 수 있다.
- media screen에 (orientation: landscape)를 이용하면, 세로모드인지 가로모드인지도 구별 할 수 있다.

@media screen and (min-width: 650px) and (max-width: 750px) and (orientation: landscape){   ---->만약 screen의 너비가 650px보다 크고 750px보다 작다면 그리고 가로모드(세로: portrait)라면 아래의 속성들을 적용해줘! 란 뜻
    div{
        background-color: tomato;
    }
}

------가로모드로 했을 때 문구 없애기-----
@media screen and (orientation: landscape){
    span {
        display: none;                 --> 말 그래도 안 보여주겠단 뜻임
    }
}

<span>please flip your phone</span>


-----Media Queries 주요기능
- min-device-width
- max-device-width
- orientation: landscape
- orientation: portrait
- aspect-ration - 레티나디스플레이 감지가능
- display-mode
- inverted-colors
- lightlevel
- prefers-contrast
- resolution
- monochrome

Media type
- @media screen{}
- @media print{}      -> 프린트 할 때 속성 적용.

[Using media queries](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)

@media print {
    span{
        color: tomato;
    }
    body{
        background-color: aquamarine;
    }
}
    <div></div>
    <span>please flip your phone</span>

    5.0 git?
git의 필요성
    
- 코드가 긴 경우에는 파일의 히스토리를 알고 있어야 한다. 처음에 뭘 작성했는지, 나중에 뭘 추가했는지, 변경 내역 등을 알고 있어야 하는데 이럴 때 git을 사용하면 것이 도움이 된다.
- 내가 원하는 파일의 변경된 내용을 확인 할 수 있다.
- git은 programming에서 주로 사용되는 도구다.
- text 파일에서만 사용 할 수 있는 것이 아니라, excel, image, song 등등 다른 파일 형식에도 사용 할 수 있다.(git 시스템은 파일을 binary format(0101010 같은 것)으로 인식하기 때문)
- git은 어떤 파일이든 수정된 내역을 알 수 있다.
- code에 주로 사용되는 도구이지만, 다른 형식의 파일도 변경 내역을 추적하는데 사용할 수 있다.
    
 ⇒ 한마디로, git은 파일을 계속 추적(Tracking)하는 것이다.

github의 필요성

- 코딩 작업을 열심히 해놨는데, 컴퓨터를 잃어버리고 파일도 날아가고 변경한 기록도 사라지는 경우를 대비해서 github을 사용한다.
- github에는 기본적으로 변경내역을 업로드 한다.

- git은 계속 추적하면서 변경내역을 관리해주고, github에는 그 변경내역을 업로드한다.
- git은 파일의 변경내역을 게속해서 추적해주는 version control system
- github은 파일 내역과 파일들을 올려주는 공간